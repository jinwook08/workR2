mean(d2)
md2<- mean(d2)
md1 <- mean(d1)
md2-md1
# 8. d1 내림차순으로 정렬해서 출력
sort(d1, decending= T)
# 8. d1 내림차순으로 정렬해서 출력
sort(d1,decending=T)
# 8. d1 내림차순으로 정렬해서 출력
sort(d1,decreasing = T)
# 9. d1, d2  오름차순으로 정렬 후 각 10개씩을 추출하여 d3에 저장
d1 <- sort(d1)
d2 <- sort(d2)
head(d2,10)
head(d1,10)
d1 <- sort(d1)
d2 <- sort(d2)
d1 <- head(d1,10)
d2<- head(d2,10)
d3 <- d1+d2
d3
d3 <- union(d1,d2)
d3
v1<60
v1(60)
작은 수 모두 출력
v1 <- 51:90
v1(60)
i
print(i)
v1 <- 51:90
for (i in v1)
if i<=60
print(i)
break
v1 <- 51:90
for (i in v1)
if i>=60
break
print(i)
# 1. 60보다 작은 수 모두 출력
v1 <- 51:90
for (i in v1){
if(i>=60)
break
print(i)
}
# 2. 70
v1[60>=i]
v1[v1>=]
v1[v1>=60]
v1[v1=<60]
v1[v1=<0]
v1[v1<=60]
if(i<=60)
v1 <- 51:90
for (i in v1){
if(i<=60)
break
print(i)
}
v1 <- 51:90
for (i in v1){
if(i<=60)
break
print(i)
}
[v1<=60]
[v1<=60]
v1[v1<=60]
v1 <- 51:90
for (i in v1){
if(i<=60)
break
print(i)
}
v1 <- 51:90
for (i in v1){
if(i<=60)
break
print(i)
}
v1 <- 51:90
for (i in v1){
if(i<=60)
print(i)
break
}
v1 <- 51:90
for (i in v1){
if(i<=60)
print(i)
break
}
v1 <- 51:90
for (i in v1){
if(i<=60)
print(i)
break
}
v1 <- 51:90
for (i in v1){
if(i<=60)
print(i)
break
}
v1 <- 51:90
for (i in v1){
if(i<=60)
print(i)
break
}
v1 <- 51:90
for (i in v1){
if(i<=60)
print(i)
break
}
v1 <- 51:90
for (i in v1){
if(i<=60)
print(i)
break
}
}
v1 <- 51:90
for (i in v1){
if(i<=60)
print(i)
}
v1 <- 51:90
print(v1)
for (i in v1){
if(i>59)
break
print(i)
}
v1 <- 51:90
for (i in v1){
if(i>59)
print(i)
}
if(i<59)
v1 <- 51:90
for (i in v1){
if(i<59)
print(i)
}
# 1. 60보다 작은 수 모두 출력
v1 <- 51:90
for (i in v1){
if(i<60)
print(i)
}
v2 <- v1[v1<70]
length(v2)
# 3. 65보다 큰 수들의 합 출력
v2 <- v1[v1>65]
sum(v2)
# 4. 60보다 크고 73보다 작은 수를 출력
v1[v1>60&73>v1]
i
v3 <- print(i)
# 5. 65보다 작거나 80보다 큰 수를 모두 출력
v1[v1>80&65>v1]
# 5. 65보다 작거나 80보다 큰 수를 모두 출력
v1[v1>80|65>v1]
# 6. 7로 나누었을때 나머지가 3인 수를 모두 출력
v1[v1%%7==3]
# 7. 7의 배수들의 값을 0으로 변경
v1[v1%%7==0] <- 0
v1
# 8. 짝수를 모두 합한 값을 출력
max(v1[v1%%2==0])
# 9. 홀수이거나 80보다 큰 수를 모두 출력
v1[v1%%==1|v1>80]
v1[v1%%==1|v1>80]
# 9. 홀수이거나 80보다 큰 수를 모두 출력
v1[v1%%2==1|v1>80]
# 9. 홀수이거나 80보다 큰 수를 모두 출력
v1[v1%%2==1|v1>80]
# 10. 3과 5의 공배수 출력
v1[v1%%3==0&v1%%5==0]
# 10. 3과 5의 공배수 출력
v1 <- 51:90
v1[v1%%3==0&v1%%5==0]
v1[v1%%3==0&v1%%5==0]
# 11. 짝수에 대해서만 2를 곱해서 저장
v1[v1%%==0]*2
v1[v1%%2==0]*2
# 12. 7의 배수들을 제거한 후 v1 내용 출력
v1[v1%%7==!0]
# 12. 7의 배수들을 제거한 후 v1 내용 출력
v1[v1%%7!==0]
# 12. 7의 배수들을 제거한 후 v1 내용 출력
v1[v1%%7 !==0]
v1
# 12. 7의 배수들을 제거한 후 v1 내용 출력
v1
v1
v1[v1%%7 !==0]
v1
v1[v1%%7 !==0]
v1
v1[v1%%7 !==0]
v1
v1[v1%%7 !==0]
v1
v1[v1%%7 !==0]
v1
v1[v1%%7 !==0]
v1
v1[v1%%7 !==0]
v1
v1[v1%%7 !==0]
v1
v1[v1%%7 !==0]
v1
v1[v1%%7 !==0]
v1[v1%%7 !=0]
v1[v1%%7 !=0]
v1
v1[v1%%7 !=0]
#
# 문1)
# >score
# m  f
# [1,] 10 21
# [2,] 40 60
# [3,] 60 70
# [4,] 20 30
#
# 1. 위와 같은 내용의 matrix score를 생성
m <- (10,40,60,20)
m <- (10,40,60,20)
f <- c(21,60,70,30)
matrix(m,f)
# 1. 위와 같은 내용의 matrix score를 생성
m <- c(10,40,60,20)
f <- c(21,60,70,30)
matrix(m,f)
score <- data.frame(m,f)
score
# 2. score의 열 이름을 각각 male, female로 바꾸시오
score <- c(male,female)
# 1. 위와 같은 내용의 matrix score를 생성
m <- c(10,40,60,20)
f <- c(21,60,70,30)
score <- data.frame(m,f)
score
# 2. score의 열 이름을 각각 male, female로 바꾸시오
score <- c(male,female)
# 2. score의 열 이름을 각각 male, female로 바꾸시오
colnames(score) <- c(male,female)
# 2. score의 열 이름을 각각 male, female로 바꾸시오
score <- c('male','female')
score
m <- c(10,40,60,20)
f <- c(21,60,70,30)
score <- data.frame(m,f)
score
# 2. score의 열 이름을 각각 male, female로 바꾸시오
clonames(score)<- c('male','female')
# 2. score의 열 이름을 각각 male, female로 바꾸시오
c0lnames(score)<- c('male','female')
# 2. score의 열 이름을 각각 male, female로 바꾸시오
colnames(score)<- c('male','female')
male
score
# 3. 2행에 있는 모든 값을 출력
score
# 4. female의 모든 값을 출력
score(,2)
# 4. female의 모든 값을 출력
score[,2]
# 5. 3행 2열의 값을 출력
#
score[3,2]
# 문2)
# R에서 제공하는 state.x77 데이터셋을 이용하여 작성
#
# 1. state.x77을 변환하여 st에 data frame으로 작성
str(state.x77)
st <- data.frame(state.x77)
# 2. st의 내용을 출력
st
# 3. st의 열 이름 출력
colnames(st)
# 4. st의 행 이름 출력
rownames(St)
# 4. st의 행 이름 출력
rownames(st)
# 5. st의 행의 개수와 열의 개수 출력
cor(St)
# 5. st의 행의 개수와 열의 개수 출력
cor(st)
# 5. st의 행의 개수와 열의 개수 출력
dim(st)
# 5. st의 행의 개수와 열의 개수 출력
nrow(st)
ncol(st)
# 6. st의 요약 정보 출력
str(St)
# 6. st의 요약 정보 출력
str(st)
# 7. st의 행별 합계와 평균 출력
rowSums(st)
# 8. st의 열별 합계와 평균 출력
colSums(st)
# 9. Florida 주의 모든 정보 출력
st['Florida']
# 9. Florida 주의 모든 정보 출력
st[,'Florida']
# 9. Florida 주의 모든 정보 출력
st[,Florida]
# 9. Florida 주의 모든 정보 출력
st$Florida
# 9. Florida 주의 모든 정보 출력st
st
# 9. Florida 주의 모든 정보 출력st
st[Florida,]
st['Florida',]
# 10. 50개 주의 수입(Income) 정보만 출력
st$Income
# 11. Texas 주의 면적(Area)을 출력
st['Texas',]$Area
# 12. Ohio 주의 인구(Population)와 수입(Income) 출력
st['Ohio',]$Population$Income
# 12. Ohio 주의 인구(Population)와 수입(Income) 출력
st['Ohio',]$Population
# 12. Ohio 주의 인구(Population)와 수입(Income) 출력
st['Ohio',c('Population','Income')]
# 13. 인구가 5,000 이상인 주의 데이터만 출력
st$Population>5000
# 13. 인구가 5,000 이상인 주의 데이터만 출력
subset(st,Population>=5000)
# 14. 수입이 4,500 이상인 주의 인구, 수입, 면적을 출력
subset(st,'Population','Income','Area')
# 14. 수입이 4,500 이상인 주의 인구, 수입, 면적을 출력
subset(st,Income>=4500)[,c('Population','Income','Area')]
subset(St,Income>=4500, select=c('Income','Population','Area'))
subset(stt,Income>=4500, select=c('Income','Population','Area'))
subset(st,Income>=4500, select=c('Income','Population','Area'))
# 15. 수입이 4,500 이상인 주는 몇 개인지 출력
nrow(subset(st,Income>=4500))
# 16. 전체 면적(Area)이 100,000 이상이고, 결빙일수(Frost)가 120 이상인 주의 정보 출력
subset(st,Area>=100000&Forst>=120)
# 16. 전체 면적(Area)이 100,000 이상이고, 결빙일수(Frost)가 120 이상인 주의 정보 출력
subset(st,Area>=100000&Frost>=120)
# 17. 인구(Population)가 2,000 미만이고, 범죄율(Murder)이 12미만인 주의 정보 출력
subset(st,Population<2000&Murder<12)
# 18. 문맹률(Illiteracy)이 2.0 이상인 주의 평균 수입은 얼마인지 출력
mean(subset(st,Illiteracy>2)[,'Income'])
subset(st,Illieracy>2)[,'Income']
subset(st,Illiteracy>2)[,'Income']
# 19. 문맹률(Illiteracy)이 2.0 미만인 주와 2.0 이상인 주의 평균 수입의 차이 출력
mean(subset(st,Illiteracy>2)[,'Income']) - mean(subset(st,Illiteracy<2)[,'Income'])
# 20. 기대수명(Life Exp)이 가장 높은 주는 어디인지 출력
subset(st,max(Life Exp))
# 20. 기대수명(Life Exp)이 가장 높은 주는 어디인지 출력
max(st$Life.Exp)
# 20. 기대수명(Life Exp)이 가장 높은 주는 어디인지 출력
ml<- max(st$Life.Exp)
subset(st,Life Exp==ml)
subset(st,Life Exp==ml)
subset(st,Life.Exp==ml)
# 19. 문맹률(Illiteracy)이 2.0 미만인 주와 2.0 이상인 주의 평균 수입의 차이 출력
abs(mean(subset(st,Illiteracy>2)[,'Income']) - mean(subset(st,Illiteracy<2)[,'Income']))
rownames(subset(st,Life.Exp==ml))
# 21 Pennsylvania 주보다 수입(Income)이 높은 주들 출력
#
pp <- st["Pennsylvania",]
# 21 Pennsylvania 주보다 수입(Income)이 높은 주들 출력
#
pp <- st["Pennsylvania",'Income']
pp
pp
subset(st,Income>pp)
rownames(subset(st,Income>pp))
# 문3)
# R에서 제공하는 mtcars 데이터셋은 자동차 모델에 대한 제원 정보를 담고 있다.
#
# 1. 이 데이터셋의 자료구조 출력
str(mtacar)
s
# 문3)
# R에서 제공하는 mtcars 데이터셋은 자동차 모델에 대한 제원 정보를 담고 있다.
#
# 1. 이 데이터셋의 자료구조 출력
class(mtcars)
# 문3)
# R에서 제공하는 mtcars 데이터셋은 자동차 모델에 대한 제원 정보를 담고 있다.
#
# 1. 이 데이터셋의 자료구조 출력
str(mtcars)
# 2. 이 데이터셋의 행의 개수와 열의 개수 출력
dim(mtcars)
class(mtcars)
# 3. 이 데이터셋 열들의 자료형 출력
str(mtcars)
# 4. 연비(mpg)가 가장 좋은 자동차 모델 출력
mtacars$mpg
# 4. 연비(mpg)가 가장 좋은 자동차 모델 출력
mtcars$mpg
# 4. 연비(mpg)가 가장 좋은 자동차 모델 출력
max(mtcars$mpg)
# 4. 연비(mpg)가 가장 좋은 자동차 모델 출력
mm<- max(mtcars$mpg)
subset(mtcars,mpg==mm)
rownames(subset(mtcars,mpg==mm))
# 5. gear가 4인 자동차 모델 중 연비가 가장 낮은 모델 출력
mp <- min(mtcars$mpg)
mp
rownames(subset(mtcars,gear==4&mpg==mp))
rownames(subset(mtcars,gear==4&mpg==mp))
mp <- min(mtcars$mpg)
rownames(subset(mtcars,gear==4&mpg==mp))
rownames(subset(mtcars,gear==4&mpg==10.4))
mst <- subset(mtcars,geat==4)
mst <- subset(mtcars,gear==4)
rownames(mst,mpg==mp)
mp <- min(mtcars$mpg)
# 5. gear가 4인 자동차 모델 중 연비가 가장 낮은 모델 출력
mp <- min(mtcars$mpg)
mst <- subset(mtcars,gear==4)
rownames(mst,mpg==mp)
rownames( mtcars[ mtcars$mpg == min.mpg, ] ) # 방법 1
min.mpg <- min( mtcars[ mtcars$gear == 4, 'mpg' ] )
rownames( mtcars[ mtcars$mpg == min.mpg, ]
min.mpg <- min( mtcars[ mtcars$gear == 4, 'mpg' ] )
rownames( mtcars[ mtcars$mpg == min.mpg, ] ) # 방법 1
rownames(subset(mst,mpg==mp))
rownames(subset(mst,mpg==mp))
mst <- subset(mtcars,gear==4)
# 5. gear가 4인 자동차 모델 중 연비가 가장 낮은 모델 출력
mp <-min(mtcars$mpg)
mp
subset(mtcars, gear==4)
subset(mtcars, gear==4&mpg==mp)
rownames(subset(mg,gear==4&min(mpg)))
rownames(subset(mtcars,gear==4&min(mpg)))
rownames(subset(mtcars,gear==4&min(mpg)))
# 5. gear가 4인 자동차 모델 중 연비가 가장 낮은 모델 출력
mg <- min(mtcars[mtcars$mpg==4,'mpg'])
# 5. gear가 4인 자동차 모델 중 연비가 가장 낮은 모델 출력
mg <- subset(mtcars,gear==4)
rownames(subset(mg,mpg==min(min(mg[,'mpg']))))
rownames(subset(mg,mpg==min(mg[,'mpg'])))
# 6. Honda Civic의 연비(mpg)와 gear 수 출력
HC <- mtcars["Honda Civic",]
HC[,c('mpg','gear')]
# 7. Pontiac Firebird 보다 연비가 좋은 자동차 모델 출력
PF <- mtcars['Pontiac Firebird','mpg']
PF
subset(mtcars,mpg>PF4)
subset(mtcars,mpg>PF)
mean(mtcars$mpg)
# 9. gear의 수 종류 출력
unique(mtcars$gear)
#
# 문4)
# R에서 제공하는 airquality 데이터셋은 일별로 대기의 질을 측정한 정보를 담고 있다.
#
# 1. 이 데이터셋의 자료구조 출력
class(airquality)
# 2. 이 데이터셋의 앞쪽 일부분 내용만 출력
head(airquality)
# 3. 기온(Temp)이 가장 높은 날은 언제인지 월(Month)과 일(Day) 출력
airquality$Tm
# 3. 기온(Temp)이 가장 높은 날은 언제인지 월(Month)과 일(Day) 출력
airquality$Temp
# 3. 기온(Temp)이 가장 높은 날은 언제인지 월(Month)과 일(Day) 출력
aT <- airquality$Temp
# 3. 기온(Temp)이 가장 높은 날은 언제인지 월(Month)과 일(Day) 출력
aT <- max(airquality$Temp)
atT[,c('Month','Day')]
aT[,c('Month','Day')]
aT[,c('Month','Day')]
aT <- max(airquality$Temp)
aT[ ,c('Month','Day')]
aT <- max(aT)
aT <- subset(airquality,Temp==aT)
aT1 <- subset(airquality,Temp==aT)
aT1 <- subset(airquality,Temp==aT)
aT1[,c('Month','Day')]
ai1 <- ai[, 'Temp']
ai2 <- max(ai1)
ai3 <- subset(ai,Temp==ai2)
ai3[,c('Month','Day')]
ai <- data.frame(airquality)
ai1 <- ai[, 'Temp']
ai2 <- max(ai1)
ai3 <- subset(ai,Temp==ai2)
ai3[,c('Month','Day')]
작성하시오. 단, 제목과 x축 레이블은 ‘기어의 수’, y축 레이블
# 은 ‘빈도수’로 나타내시오.
#
install.packages('tidyverse')
library(tidyverse)
library(ggplot2)
class(mtcars)
ggplot(data=mtcars,mapping=aes(x=mtcars$gear))+
geom_bar(stat='identity',width=0.7,fill='blue')
# 문2)
# R에서 제공하는 mtcars 데이터셋에서 cyl(실린더의 수)에 대해 막대 색이
# 초록색인 막대그래프를 ggplot으로 작성하시오.
install.packages('tidyverse')
library(tidyverse)
library(ggplot2)
class(mtcars)
ggplot(data=mtcars,mapping=aes(x=mtcars$gear))+
geom_bar(stat='identity',width=0.7,fill='blue')
