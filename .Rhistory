iris[order(iris$Species,decreasing = T,
iris$Sepal.Length),]    #정렬 기준을 2개 설정.
iris[order(iris$Sepal.Length, decreasing = T),]
#
# 문4)
# R에서 제공하는 state.x77 데이터셋에 대하여 다음 문제를 해결하기 위한
# R 코드를 작성하시오.
#
# (1) state.x77 데이터셋을 Population(인구수)를 기준으로 오름차순 정렬하시오
st <- state.x77
st[order(state$Population)]
st[order(st$Population)]
st[order(st$Population,decreasing = T),]
st[order(st$Population,decreasing = T),]
st1 <- sort(st, decreasing = T)
st1
order( iris$Sepal.Length )   #정렬시켜주는데 그 정렬시킨애들 순서만을 나타낸다.
iris[order(iris$Sepal.Length),]   #Ascending  #이때 옆에 나오는 숫자는 원래 몇번째에 있던 꽃인지 말해준다.
st
st[order(st$Population, decreasing = T),]
state.x77[order(state.x77$Population, decreasing = T), ]
#
# 문4)
# R에서 제공하는 state.x77 데이터셋에 대하여 다음 문제를 해결하기 위한
# R 코드를 작성하시오.
#
# (1) state.x77 데이터셋을 Population(인구수)를 기준으로 오름차순 정렬하시오
class(state.x)
#
# 문4)
# R에서 제공하는 state.x77 데이터셋에 대하여 다음 문제를 해결하기 위한
# R 코드를 작성하시오.
#
# (1) state.x77 데이터셋을 Population(인구수)를 기준으로 오름차순 정렬하시오
class(state.x77)
class(state.x77)
st <- data.frame( state.x77)
st[order(st$Population, decreasing = T),]
state.x77[order(state.x77$Population, decreasing = T), ]
# (2) state.x77 데이터셋을 Income(소득)을 기준으로 내림차순 정렬하시오.
st[order(st$Income),]
st[order(st$Income),]
sstv <-colnames(sort(st))
sstv <- sort(colnames(st$Illiteracy))
sstv
sstv
# (3) Illiteracy(문맹률)가 낮은 상위 10개 주의 이름과 문맹률을 출력하시오.
#
st[order(st$Illiteracy),]
colnames(stt(head(10)))
2) state.x77 데이터셋을 Income(소득)을 기준으로 내림차순 정렬하시오.
st[order(st$Income),]
# (3) Illiteracy(문맹률)가 낮은 상위 10개 주의 이름과 문맹률을 출력하시오.
#
stt<- st[order(st$Illiteracy),]
colnames(stt(head(10)))
st[order(st$Income),]
stt<- st[order(st$Illiteracy),]
colnames(stt(head(10)))
stt[1:10]
stt<- st[order(st$Illiteracy),]
stt[1:10]
stt[,1:10]
stt<- st[order(st$Illiteracy),]
stt[,1:10]
colnames(stt)
rownames
rownames(stt)
stt
rownames(stt[1:10,])
# 문5)
# R에서 제공하는 mtcars 데이터셋에 대하여 다음 문제를 해결하기 위한 R
# 코드를 작성하시오.
#
# (1) mtcars 데이터셋을 gear(기어)의 개수에 따라 그룹을 나누어 mt.gear에 저장하
# 시오.(단, split() 함수를 사용)
class(mtcars)
split(gear,1)
mt.gear<- split(gear,1)
mt.gear<- split(mtcars, mtcars$gear)
mt.gear
mt.gear$4
mt.gear$4
mt.gear$`4`
# (3) mt.gear에서 gear(기어)의 개수가 3인 그룹과 5인 그룹의 데이터를 합쳐서
# mt.gear.35에 저장하고 내용을 출력하시오.
mt.gear3 <- mt.gear$'3'
mt.gear3 <- mt.gear$'3'
mt.gear5 <- mt.gear$'5'
mte.gear.35 <- merge(mt.gear3,mt.gear5)
mt.gear.35 <- merge(mt.gear3,mt.gear5)
mt.gear.35
mt.gear.35 <- merge(mt.gear3,mt.gear5=c('names'))
# (3) mt.gear에서 gear(기어)의 개수가 3인 그룹과 5인 그룹의 데이터를 합쳐서
# mt.gear.35에 저장하고 내용을 출력하시오.
mt.gear3 <- mt.gear$'3'
mt.gear5 <- mt.gear$'5'
mt.gear.35 <- merge(mt.gear3,mt.gear5=c('names'))
mt.gear.35
mt.gear.35 <- merge(mt.gear3,mt.gear5,by=c('names'))
과 5인 그룹의 데이터를 합쳐서
# mt.gear.35에 저장하고 내용을 출력하시오.
mt.gear3 <- mt.gear$'3'
mt.gear5 <- mt.gear$'5'
mt.gear.35 <- merge(mt.gear3,mt.gear5,by=c('names'))
mt.gear.35
mt.gear.35 <- merge(mt.gear3,mt.gear5,all=T)
mt.gear.35
mt.gear$`4`
# (3) mt.gear에서 gear(기어)의 개수가 3인 그룹과 5인 그룹의 데이터를 합쳐서
# mt.gear.35에 저장하고 내용을 출력하시오.
mt.gear3 <- mt.gear$'3'
mt.gear3
mt.gear.35 <- merge(mt.gear3,mt.gear5,all=T)
mt.gear.35
mt.gear5
x <- data.frame(name=c('a','b','c'),
mat= c(90,80,40))
y <- data.frame(sname=c('a','b','d'),
korean=c(75,60,90))
z <- merge(x,y,by.x=c('name'),
by.y = c('sname'))
z
mt.gear5
mt.gear5
mt.gear3
subset(mtcars, wt<=3.0 & wt>=1.5)
merge(authors,books,by.authors=c('surneme'),by.books=c('name'))
authors <- data.frame( surname = c( "Twein", "Venables", "Tierney", "Ripley", "McNeil" ),nationality = c( "US", "Australia", "US", "UK", "Australia" ),retired = c( "yes", rep( "no", 4 ) ) )
books <- data.frame( name = c( "Johns", "Venables", "Tierney", "Ripley", "Ripley", "McNeil" ),title = c( "Exploratory Data Analysis", "Modern Applied Statistics ...", "LISP-STAT","Spatial Statistics", "Stochastic Simulation","Interactive Data Analysis" ),other.author = c( NA, "Ripley", NA, NA, NA, NA ) )
merge(authors,books,by.authors=c('surneme'),by.books=c('name'))
merge(authors,books,all.authors=T)
# (3) surname과 name을 공통 열로 하여 authors와 books를 병합하여 출력하되 books
# 의 행들은 모두 표시되도록 하시오.
rownames(authors)
authors
# (3) surname과 name을 공통 열로 하여 authors와 books를 병합하여 출력하되 books
# 의 행들은 모두 표시되도록 하시오.
merge(authors,books,all.books=T)
books
# (3) surname과 name을 공통 열로 하여 authors와 books를 병합하여 출력하되 books
# 의 행들은 모두 표시되도록 하시오.
merge(books,authors,all.books=T)
# (3) surname과 name을 공통 열로 하여 authors와 books를 병합하여 출력하되 books
# 의 행들은 모두 표시되도록 하시오.
merge(books,authors,
by.authors=c('surname')
all.books=T)
# 의 행들은 모두 표시되도록 하시오.
merge(books,authors,
by.authors=c('surname')
all.books=T)
통 열로 하여 authors와 books를 병합하여 출력하되 books
# 의 행들은 모두 표시되도록 하시오.
merge(books,authors,
by.authors=c('surname'),
all.books=T)
merge(authors,books,
by.books=c('name')
all.authors=T)
merge(authors,books,
by.books=c('name'),
all.authors=T)
merge(books,authors,
by.books=c('surname'),
by.authors=c('other.author'))
ds <- state.x77
ds[2,3] <- NA
ds[3,1] <- NA
ds[2,4] <- NA
ds[4,3] <- NA
# (1) 각 열별로 결측값이 몇 개인지 출력하시오.
na_count <- apply(ds,2,function(df)sum(is.na(df)))
na_count
# (2) 결측값이 포함된 행들의 데이터를 출력하시오.
ds[!complete.cases(ds),]
# (3) 결측값이 포함된 행은 몇 개인지 출력하시오.
rowSums(is.na(ds))
sum(rowSums(is.na(ds))>0)
# (4) 결측값이 포함된 행들을 제외하고 새로운 데이터셋 ds.new를 만들어보시오.
#
ds.new <- ds[complete.cases(ds),]
ds.new
# 문2)
# 다음과 같이 state.x77 데이터셋을 st에 저장한 후 다음 문제를 해결하기
# 위한 R 코드를 작성하시오.
#
# st <- data.frame(state.x77)
#
# (1) st의 각 변수(열)들에 대해 특이값이 존재하는지 상자그림을 그려 확인하시오.
st <- data.frame(state.x77)
boxplot(st)
state.x77
summary(st$Area)
# (2) 특이값이 존재하는 경우 이상치를 NA로 대체하여 저장하시오.
out.val <- boxplot.stats(st$Area)$out
st$Area[st$Area %in% out.val] <- NA
head(st)
# (3) st에서 NA가 존재하는 행들을 제거하여 st2에 저장하시오.
#
new <- st[complete.cases(st),]
head(new)
# 문3)
# R에서 제공하는 airquality 데이터셋에 대해 다음의 문제를 해결하기 위한
# R 코드를 작성하시오.
#
# (1) airquality를 AQ에 저장하시오.
AQ <- airquality
# (2) AQ에서 열별로 NA의 개수를 출력하시오.
AQ_count <- apply(AQ,2,function(air)sum(is.na(air)))
AQ_count
# (3) AQ에서 행별로 NA의 개수를 출력하시오.
AQ_count1 <- apply(AQ,1,function(air)sum(is.na(air)))
AQ_count1
# (4) AQ에서 NA를 포함하지 않은 행들만 출력하시오.
AQ[complete.cases(AQ),]
# (5) AQ에서 NA를 NA가 속한 열의 평균값으로 치환하여 AQ2로 저장하고, AQ2의 내용을
# 출력하시오.
AQ2<- colMeans(AQ,na.rm = T)
AQ2
#
# 문4)
# R에서 제공하는 state.x77 데이터셋에 대하여 다음 문제를 해결하기 위한
# R 코드를 작성하시오.
#
# (1) state.x77 데이터셋을 Population(인구수)를 기준으로 오름차순 정렬하시오
class(state.x77)
st <- data.frame( state.x77)
st[order(st$Population, decreasing = T),]
# (2) state.x77 데이터셋을 Income(소득)을 기준으로 내림차순 정렬하시오.
st[order(st$Income),]
# (3) Illiteracy(문맹률)가 낮은 상위 10개 주의 이름과 문맹률을 출력하시오.
#
stt<- st[order(st$Illiteracy),]
stt
rownames(stt[1:10,])
# 문5)
# R에서 제공하는 mtcars 데이터셋에 대하여 다음 문제를 해결하기 위한 R
# 코드를 작성하시오.
#
# (1) mtcars 데이터셋을 gear(기어)의 개수에 따라 그룹을 나누어 mt.gear에 저장하
# 시오.(단, split() 함수를 사용)
class(mtcars)
mt.gear<- split(mtcars, mtcars$gear)
mt.gear
# (2) mt.gear에서 gear(기어)의 개수가 4인 그룹의 데이터를 출력하시오.
mt.gear$`4`
# (3) mt.gear에서 gear(기어)의 개수가 3인 그룹과 5인 그룹의 데이터를 합쳐서
# mt.gear.35에 저장하고 내용을 출력하시오.
mt.gear3 <- mt.gear$'3'
mt.gear3
mt.gear5 <- mt.gear$'5'
mt.gear5
mt.gear.35 <- merge(mt.gear3,mt.gear5,all=T)
mt.gear.35
####앞에 행이름이 나오지않는다
# (4) mtcars 데이터셋에서 wt(중량)가 1.5~3.0 사이인 행들을 추출하여 출력하시오.
#
subset(mtcars, wt<=3.0 & wt>=1.5)
# 문6)
# 다음의 문제를 해결하기 위한 R코드를 작성하시오.
#
# 다음과 같이 데이터프레임 authors와 books를 생성하고 authors와 books의 내
# 용을 출력하시오.
#
# authors <- data.frame( surname = c( "Twein", "Venables", "Tierney", "Ripley", "McNeil" ),
#                        nationality = c( "US", "Australia", "US", "UK", "Australia" ),
#                        retired = c( "yes", rep( "no", 4 ) ) )
# books <- data.frame( name = c( "Johns", "Venables", "Tierney", "Ripley", "Ripley", "McNeil" ),
#                      title = c( "Exploratory Data Analysis",
#                                 "Modern Applied Statistics ...",
#                                 "LISP-STAT",
#                                 "Spatial Statistics", "Stochastic Simulation",
#                                 "Interactive Data Analysis" ),
#                      other.author = c( NA, "Ripley", NA, NA, NA, NA ) )
#
# (1) surname과 name을 공통 열로 하여 authors와 books를 병합하여 출력하시오(두		데이터프레임에서 공통 열의 값이 일치하는 것들만 병합).
authors <- data.frame( surname = c( "Twein", "Venables", "Tierney", "Ripley", "McNeil" ),nationality = c( "US", "Australia", "US", "UK", "Australia" ),retired = c( "yes", rep( "no", 4 ) ) )
authors
books <- data.frame( name = c( "Johns", "Venables", "Tierney", "Ripley", "Ripley", "McNeil" ),title = c( "Exploratory Data Analysis", "Modern Applied Statistics ...", "LISP-STAT","Spatial Statistics", "Stochastic Simulation","Interactive Data Analysis" ),other.author = c( NA, "Ripley", NA, NA, NA, NA ) )
books
merge(authors,books,by.authors=c('surneme'),by.books=c('name'))
# (2) surname과 name을 공통 열로 하여 authors와 books를 병합하여 출력하되
# authors의 행들이 모두 표시되도록 하시오.
merge(authors,books,
by.books=c('name'),
all.authors=T)
# (3) surname과 name을 공통 열로 하여 authors와 books를 병합하여 출력하되 books
# 의 행들은 모두 표시되도록 하시오.
merge(books,authors,
by.authors=c('surname'),
all.books=T)
# (4) surname과 other.author를 공통 열로 하여 authors와 books를 병합하여 출력하
# 시오.
merge(books,authors,
by.books=c('surname'),
by.authors=c('other.author'))
에서 NA를 NA가 속한 열의 평균값으로 치환하여 AQ2로 저장하고, AQ2의 내용을
# 출력하시오.
AQ2<- colMeans(AQ,na.rm = T)
AQ2
#
AQ(Ozone[NA:42.129310])
new <- st[complete.cases(st),]
head(new)
# 문3)
# R에서 제공하는 airquality 데이터셋에 대해 다음의 문제를 해결하기 위한
# R 코드를 작성하시오.
#
# (1) airquality를 AQ에 저장하시오.
AQ <- airquality
# (2) AQ에서 열별로 NA의 개수를 출력하시오.
AQ_count <- apply(AQ,2,function(air)sum(is.na(air)))
AQ_count
# (3) AQ에서 행별로 NA의 개수를 출력하시오.
AQ_count1 <- apply(AQ,1,function(air)sum(is.na(air)))
AQ_count1
# (4) AQ에서 NA를 포함하지 않은 행들만 출력하시오.
AQ[complete.cases(AQ),]
# (5) AQ에서 NA를 NA가 속한 열의 평균값으로 치환하여 AQ2로 저장하고, AQ2의 내용을
# 출력하시오.
AQ2<- colMeans(AQ,na.rm = T)
AQ2
AQ(Ozone[NA:42.129310])
AQ <- airquality
AQ[Ozone[NA:42.129310],]
# 문3)
# R에서 제공하는 airquality 데이터셋에 대해 다음의 문제를 해결하기 위한
# R 코드를 작성하시오.
#
# (1) airquality를 AQ에 저장하시오.
AQ <- airquality
AQ
AQ[ ,c(Ozone[NA:42.129310])]
AQ[ ,c(Ozone[NA:42.129310])]
ds <- state.x77
ds[2,3] <- NA; ds[3,1] <- NA; ds[2,4] <- NA; ds[4,3] <- NA
#
#(1) 각 열별로 결측값이 몇 개인지 출력하시오.
for ( i in 1:ncol( ds ) ) {
cat( 'column [ ', i, ' ] : ', sum( is.na( ds[ , i ] ) ), '\n' )
}
#(2) 결측값이 포함된 행들의 데이터를 출력하시오.
idx <- c()
for ( i in 1:nrow( ds ) ) {
if ( sum( is.na( ds[ i, ] ) ) > 0 ) {
idx <- c( idx, i )
}
}
ds[ idx, ]
#(3) 결측값이 포함된 행은 몇 개인지 출력하시오.
cnt <- 0
for ( i in 1:nrow( ds ) ) {
if ( sum( is.na( ds[ i, ] ) ) > 0 ) {
cnt <- cnt + 1
}
}
cnt
#(4) 결측값이 포함된 행들을 제외하고 새로운 데이터셋 ds.new를 만들어보시오.
idx <- c()
for ( i in 1:nrow( ds ) ) {
if ( sum( is.na( ds[ i, ] ) ) > 0 ) {
idx <- c( idx, i )
}
}
ds.new <- ds[ -idx, ]
ds.new
AQ2<- colMeans(AQ,na.rm = T)
AQ <- airquality
AQ
# (2) AQ에서 열별로 NA의 개수를 출력하시오.
AQ_count <- apply(AQ,2,function(air)sum(is.na(air)))
AQ_count
# (3) AQ에서 행별로 NA의 개수를 출력하시오.
AQ_count1 <- apply(AQ,1,function(air)sum(is.na(air)))
AQ_count1
# (4) AQ에서 NA를 포함하지 않은 행들만 출력하시오.
AQ[complete.cases(AQ),]
# (5) AQ에서 NA를 NA가 속한 열의 평균값으로 치환하여 AQ2로 저장하고, AQ2의 내용을
# 출력하시오.
AQ2<- colMeans(AQ,na.rm = T)
AQ2
AQ <- airquality
#(2) AQ에서 열별로 NA의 개수를 출력하시오.
for ( i in 1:ncol( AQ ) ) {
cnt <- sum( is.na( AQ[ , i ] ) )
cat( names( AQ )[ i ], '\t', cnt, '\n' )
}
#(3) AQ에서 행별로 NA의 개수를 출력하시오.
for ( i in 1:nrow( AQ ) ) {
cnt <- sum( is.na( AQ[ , i ] ) )
cat( 'row [ ', i, ' ] : ', cnt, '\n' )
}
#(4) AQ에서 NA를 포함하지 않은 행들만 출력하시오.
AQ[ complete.cases( AQ ), ]
#(5) AQ에서 NA를 NA가 속한 열의 평균값으로 치환하여 AQ2로 저장하고, AQ2의 내용을
#출력하시오.
colmean <- colMeans( AQ, na.rm = T )
colmean
AQ2 <- AQ
for ( i in 1:ncol( AQ2 ) ) {
AQ2[ is.na( AQ2[ , i ] ), i ] <- colmean[ i ]
}
AQ2
# (5) AQ에서 NA를 NA가 속한 열의 평균값으로 치환하여 AQ2로 저장하고, AQ2의 내용을
# 출력하시오.
str(AQ)
for ( i in 1:ncol( st ) ) {
outlier <- boxplot.stats( st[ , i ] )$out
if ( length( outlier ) > 0 ) {
st[ st[ , i ] %in% outlier, i ] <- NA
}
}
st
# ds[2,3] <- NA; ds[3,1] <- NA; ds[2,4] <- NA; ds[4,3] <- NA
#
ds <- state.x77
ds[2,3] <- NA
ds[3,1] <- NA
ds[2,4] <- NA
ds[4,3] <- NA
# (1) 각 열별로 결측값이 몇 개인지 출력하시오.
na_count <- apply(ds,2,function(df)sum(is.na(df)))
na_count
ds[!complete.cases(ds),]
idx <- c()
for ( i in 1:nrow( ds ) ) {
if ( sum( is.na( ds[ i, ] ) ) > 0 ) {
idx <- c( idx, i )
}
}
ds[ idx, ]
#결측치가 있을때 변수관의 관계를 통하여 확인해보는 방법.
barplot(na_count[na_count>0])
install.packages('VIM')
require(VIM)       ###라이브러리랑 같은 함수.
#결측치 자료 조합 확인용 시각화 도구
aggr(x, prop = FALSE, numbers = TRUE)
#두 개의 변수간의 결측치 관계 확인 시각화 도구
marginplot(x[c('Sepal.Width','Sepal.Length')],
pch=20,
col=c('darkgray','red','blue'))
#결측치가 있을때 변수관의 관계를 통하여 확인해보는 방법.
barplot(na_count[na_count>0])
install.packages('VIM')
require(VIM)       ###라이브러리랑 같은 함수.
#결측치 자료 조합 확인용 시각화 도구
aggr(x, prop = FALSE, numbers = TRUE)
#두 개의 변수간의 결측치 관계 확인 시각화 도구
marginplot(x[c('Sepal.Width','Sepal.Length')],
pch=20,
col=c('darkgray','red','blue'))
install.packages("VIM")
#두 개의 변수간의 결측치 관계 확인 시각화 도구
marginplot(x[c('Sepal.Width','Sepal.Length')],
pch=20,
col=c('darkgray','red','blue'))
#두 개의 변수간의 결측치 관계 확인 시각화 도구
marginplot(x[c('Sepal.Width','Sepal.Length')],
pch=20,
col=c('darkgray','red','blue'))
#두 개의 변수간의 결측치 관계 확인 시각화 도구
marginplot(x[c('Sepal.Width','Sepal.Length')],
pch=20,
col=c('darkgray','red','blue'))
#벡터로 바꾸어라.
#MAtrix/Data Frame 결측치 처리
x <- iris
x[1,2] <- NA
x[1,3] <- NA
x[2,3] <- NA
x[3,4] <- NA
head(x)
#Matrix/Data Frame 열별 결측치 확인 방법.
#for문 이용
for(i in 1:ncol(x)){
this.na <- is.na(x[ , i])
cat(colnames(x)[i],
"\t", sum(this.na),
'\n')
}
#열 별로 결측치가 몇개 있는지 파악이 가능하다.
#이 방법이 더 많이 쓰이는 방법이다 .
#apply()이용
col_na <- function(y){
return (sum(is.na(y)))
}                                   #apply(data frame,  행방향=1/열 방향=2, 함수=>반복 1회차에 실행. )
na_count <- apply(x,2,col_na)         #apply함수 자체가 반복문을 가지고 있다.
na_count
###다르게 apply를 사용하는 방법.//익명 함수를 사용하는 방법.
#이 방법을 더 많이 사용한다.
na_count <- apply(x,2,
function(y) sum (is.na(y)))
na_count
#apply(x,2 function(y) sum(is.na(y)))
#function(y) sum(is.na(y))--> 익명 함수라 한다.
#
#결측치가 있을때 변수관의 관계를 통하여 확인해보는 방법.
barplot(na_count[na_count>0])
install.packages('VIM')
require(VIM)       ###라이브러리랑 같은 함수.
#결측치 자료 조합 확인용 시각화 도구
aggr(x, prop = FALSE, numbers = TRUE)
#두 개의 변수간의 결측치 관계 확인 시각화 도구
marginplot(x[c('Sepal.Width','Sepal.Length')],
pch=20,
col=c('darkgray','red','blue'))
install.packages("VIM")
#두 개의 변수간의 결측치 관계 확인 시각화 도구
marginplot(x[c('Sepal.Width','Sepal.Length')],
pch=20,
col=c('darkgray','red','blue'))
