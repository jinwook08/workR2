##split 과 비슷하나 별도의 데이터 프레임으로 만들수 있다는게 장점이다.
#select():변수 추출
df %>% select(math)
df %>% select(science)
df %>% select(class,math,science)
df %>% select(-math)    #math를 빼고 추출해라.
#dplyr 함수 조합.
df %>%
filter(class==1) %>%
select(science)
df %>%
select(id, science) %>%
head
df %>%
select(id, science) %>%
sum
df %>%
select(id, science) %>%
max
#arrange ():정렬 sort함수와 같은 기능.
df %>% arrange(science)#오름차순
df %>% arrange(desc(science)) #내림차순.
#mutatge():파생변수 추가
df %>%
mutate(total=math+english+science) %>% head
df %>%
mutate(total=math+english+science,
average=(math+english+science)/3)%>% head
df %>%
mutate(grade=ifelse(science>=60,'pass','fail')) %>% head
#파생변수 추가할때 이걸 더 많이 쓴다.
df %>%
mutate(total=math+english+science,
average=(math+english+science)/3)%>%
mutate(grade=ifelse(average>=90,'pass',
ifelse(average<60,'fail','normal'))) %>%
head
#평균이 90이상이면 pass 60이하면  fail , 나머지는 normal.
df %>%
mutate(total=math+english+science,
average=(math+english+science)/3)%>%
arrange(desc(average)) %>%
head
#변수의 결과를 가지고 싶으면 반드시 변수에 담아서 저장해라.
#summarise():집단별 요약
#group_by(): 집단별 나누기.
df %>% summarise(mean_math=mean(math))
df %>% group_by(class) %>%              #group_by로 그룹핑 1반 하나 묶고 2반하나 묶어서 이걸로 아래에서 집단별 요약 실행.
summarise(mean_math=mean(math),
mean_english=mean(english),
mean_science=mean(science),
n=n())   #n은 빈도수를 계산해주는 함수이다.
#::--> 스코프 콜론 두개 다음에 나오는 것은 데이터셋 이름.
#패키지만 설치하고 로드 따로 안하고 특정한 패키지가 가지고 있는 데이터 셋을 사용하는 방법을 :: 콜론 두개 뒤에 데이터셋이름이다.
install.packages('ggplot2')
str(ggplot2::mpg)
mpg <- data.frame(ggplot2::mpg)
dim(mpg)
str(mpg)
head(mpg)
View(mpg)
mpg %>% group_by(manufacturer,drv) %>%
summarise(mean_cty=mean(cty)) %>%
head(10)
mpg %>% group_by(manufacturer) %>% filter(class=='suv')%>% mutate(tot=(cty+hwy)/2) %>%
summarise(mean_tot=mean(tot)) %>% arrange(desc(mean_tot)) %>% head(5)
df1 <- data.frame(id=c(1,2,3,4,5),
midterm=c(60,80,70,90,85))
total <- left_join(df1,df2,by='id')
df1 <- data.frame(id=c(1,2,3),
address=c('서울','부산','제주'),
stringsFacrors=F)
df2 <- data.frame(id=c(1,2,4),
gender=c('남','여','남'))
df1 <- data.frame(id=c(1,2,3,4,5),
midterm=c(60,80,70,90,85))
df2 <- data.frame(id=c(1,2,3,4,5),
final=c(60,80,70,90,85))
total <- left_join(df1,df2,by='id')
df1 <- data.frame(id=c(1,2,3),
address=c('서울','부산','제주'),
stringsFacrors=F)
df2 <- data.frame(id=c(1,2,4),
gender=c('남','여','남'))
dㄹ1
df1
df2
total
df_left <- left_join(df1,df2,by='if')
df_left <- left_join(df1,df2,by='id')
df_left
df_inner <- inner_join(df1,df2,by='id')
df_inner
df_full <- full_join(df1,df2,by='id')
df_full
df_inner <- inner_join(df1,df2,by='id')
df_inner
df_full <- full_join(df1,df2,by='id')
df_full
df1 <- data.frame(id=c(1,2,3,4,5),
test=c(60,80,70,90,85))
df2 <- data.frame(id=c(1,2,3,4,5),
test=c(60,80,70,90,85))
df_all <- bind_rows(df1,df2)
df_all
install.packages('pasych')
library(pspych)
library(psych)
install.packages('psych')
library(psych)
install.packages('psych')
library(psych)
install.packages("psych")
summmary(mtcars)
install.packages('psych')
library(psych)
summmary(mtcars)
install.packages("psych")
install.packages('psych')
library(psych)
summmary(mtcars)
summary
summary(mtcars)
describe(mtcars)
install.packages('descr')
require(descr)
table(df$gender)
freq(df$gender, plot = F)
df <- data.frame(id= c(1,2,4),gender=c('남','여','남'))
table(df$gender)
freq(df$gender)
freq(df$gender, plot = F)
freq(df$gender, plot = F)
freq(df$gender, plot = T)
freq(df$gender, plot = F)
freq(df$gender)
# * R Script file 이름은 "영문본인이름_제출일날짜.R" 부여하여 제출
# * R Script file의 처음에 주석으로 본인 이름과 작성일/제출일 기록
#
# 문1)
# 다음과 같이 결측값이 포함된 데이터셋 ds를 생성한 후, 다음 문제를 해결
# 하기 위한 R 코드를 작성하시오.
#
# ds <- state.x77
# ds[2,3] <- NA; ds[3,1] <- NA; ds[2,4] <- NA; ds[4,3] <- NA
#
ds <- state.x77
ds <- state.x77
ds[2,3] <- NA
ds[3,1] <- NA
ds[2,4] <- NA
ds[4,3] <- NA
na_count <- apply(ds,2,function(df)sum(is.na(df)))
na_count
# (2) 결측값이 포함된 행들의 데이터를 출력하시오.
ds[!complete.cases(ds),]
# (3) 결측값이 포함된 행은 몇 개인지 출력하시오.
is.na(ds)
pritn(!complete.cases(ds),)
print(!complete.cases(ds),)
print(names(!complete.cases(ds)),)
names(is.na(ds))
# (3) 결측값이 포함된 행은 몇 개인지 출력하시오.
is.na(ds)
# (3) 결측값이 포함된 행은 몇 개인지 출력하시오.
dd<- is.na(ds)
names(is.na(dd))
# (2) 결측값이 포함된 행들의 데이터를 출력하시오.
ds[!complete.cases(ds),]
# (3) 결측값이 포함된 행은 몇 개인지 출력하시오.
rowSums(is.na(ds))
sum(rowSums(is.na(ds))>0)
# (4) 결측값이 포함된 행들을 제외하고 새로운 데이터셋 ds.new를 만들어보시오.
#
dd <- ds[complete.cases(ds),]
# (4) 결측값이 포함된 행들을 제외하고 새로운 데이터셋 ds.new를 만들어보시오.
#
ds.new <- ds[complete.cases(ds),]
ds.new
st <- data.frame(state.x77)
boxplot(st)
boxplot.stats(st)
boxplot.stats(st)$out
t <- data.frame(state.x77)
boxplot(st)
boxplot.stats(st)$out
boxplot.stats(st$Area)$out
#특이값, 이상치(outlier)
st <- data.frame(state.x77)
summary(st$Income)
boxplot(st$Income)
boxplot.stats(st$Income)$out
#데이터를 알고 이 데이터가 문자열이 맞느냐 숫자형이 맞느냐를 전부 따져보고 그 이후에.
#데이터 분석을할때 가장 먼저 할것 결측치와 이상치부터 찾아본다.
##특이값 처리: NA로 변환 후 결측치 처리방법 이용.
out.val <- boxplot.stats(st$Income)$out
st$Income[st$Income %in% out.val] <- NA    #%in% 포함여부를 나타내는 연산자.
head(st)
newdata <- st[complete.cases(st),]
head(newdata)
########################데이터 정제를 지금까지 해 보았다.
#Data정제를 한다는건
#결측치 처리
#이상치 처리.
state.x
state.x77
out.val <- boxplot.stats(st$Area)$out
summary(st$Area)
st$Area[st$Area %in% out.val] <- NA
head(st)
# (1) st의 각 변수(열)들에 대해 특이값이 존재하는지 상자그림을 그려 확인하시오.
st <- data.frame(state.x77)
boxplot(st)
state.x77
summary(st$Area)
# (2) 특이값이 존재하는 경우 이상치를 NA로 대체하여 저장하시오.
out.val <- boxplot.stats(st$Area)$out
st$Area[st$Area %in% out.val] <- NA
head(st)
new <- st[complete.cases(st),]
head(st)
new <- st[complete.cases(st),]
head(st)
head(new)
# 문3)
# R에서 제공하는 airquality 데이터셋에 대해 다음의 문제를 해결하기 위한
# R 코드를 작성하시오.
#
# (1) airquality를 AQ에 저장하시오.
AQ <- airquality
AQ_count <- apply(AQ,2,function(air)sum(is.na(air)))
AQ_count
# (3) AQ에서 행별로 NA의 개수를 출력하시오.
AQ_count <- apply(AQ,1,function(air)sum(is.na(air)))
AQ_count1 <- apply(AQ,1,function(air)sum(is.na(air)))
AQ_count1
AQ_count1 <- apply(AQ,1,function(air)sum(is.na(air)))
AQ_count1
AQ_count <- apply(AQ,2,function(air)sum(is.na(air)))
AQ_count
# (4) AQ에서 NA를 포함하지 않은 행들만 출력하시오.
AQ[complete.cases(AQ),]
# (2) AQ에서 열별로 NA의 개수를 출력하시오.
AQ_count <- apply(AQ,2,function(air)sum(is.na(air)))
AQ_count
# (5) AQ에서 NA를 NA가 속한 열의 평균값으로 치환하여 AQ2로 저장하고, AQ2의 내용을
# 출력하시오.
apply(AQ,2,mean(AQ[, c(1,2,3,4,5,6)]))
apply(AQ,2,mean(AQ[, c(1,2,3,4,5,6)]))
# (5) AQ에서 NA를 NA가 속한 열의 평균값으로 치환하여 AQ2로 저장하고, AQ2의 내용을
# 출력하시오.
AA <- complete.cases(AQ)
apply(AA,2,mean(AA[, c(1,2,3,4,5,6)]))
apply(AA,2,mean(AA[, c(1,2,3,4,5)]))
AA
# (4) AQ에서 NA를 포함하지 않은 행들만 출력하시오.
AQ[complete.cases(AQ),]
# (5) AQ에서 NA를 NA가 속한 열의 평균값으로 치환하여 AQ2로 저장하고, AQ2의 내용을
# 출력하시오.
AA <- AQ[complete.cases(AQ)]
AA <- AQ[complete.cases(AQ)]
for(i in 1:ncol(AQ)){
this.na <- is.na(AQ[ , i])
cat(colnames(AQ)[i],
"\t", sum(this.na),
'\n')
}
# (5) AQ에서 NA를 NA가 속한 열의 평균값으로 치환하여 AQ2로 저장하고, AQ2의 내용을
# 출력하시오.
AQ[,c(1,2,3,4,5,6)]
AQ
is.na(AQ)
sum(AQ,na.rm=TRUE)
apply(AQ,2,na.rm=TRUE)
apply(AQ,2,na.rm=TRUE)
apply(AQ,2,function(y)na.rm=TRUE)
apply(AQ,2,function(y)mean(AQ,na.rm=TRUE))
apply(AQ,2,mean(AQ,na.rm=TRUE))
st$Area$Incom[st$Area %in% out.val] <- NA
st$Area[st$Area %in% out.val] <- NA %>% st$Population[st$Population %in% out.val] <- NA
out.val <- boxplot.stats(st$Area)$out %>% boxplot.stats(st$Population)$out
# 문2)
# 다음과 같이 state.x77 데이터셋을 st에 저장한 후 다음 문제를 해결하기
# 위한 R 코드를 작성하시오.
#
# st <- data.frame(state.x77)
#
library(dplyr)
# (2) 특이값이 존재하는 경우 이상치를 NA로 대체하여 저장하시오.
out.val <- boxplot.stats(st$Area)$out %>% boxplot.stats(st$Population)$out
st$Area[st$Area %in% out.val] <- NA %>% st$Population[st$Population %in% out.val] <- NA
library(dplyr)
st$Area[st$Area %in% out.val] %>% st$Population[st$Population %in% out.val] <- NA
# (1) st의 각 변수(열)들에 대해 특이값이 존재하는지 상자그림을 그려 확인하시오.
st <- data.frame(state.x77)
boxplot(st)
state.x77
summary(st$Area)
# (2) 특이값이 존재하는 경우 이상치를 NA로 대체하여 저장하시오.
out.val <- boxplot.stats(st$Area)$out %>% boxplot.stats(st$Population)$out
st$Area[st$Area %in% out.val] %>% st$Population[st$Population %in% out.val] <- NA
head(st)
# (3) st에서 NA가 존재하는 행들을 제거하여 st2에 저장하시오.
#
new <- st[complete.cases(st),]
head(new)
# 문3)
# R에서 제공하는 airquality 데이터셋에 대해 다음의 문제를 해결하기 위한
# R 코드를 작성하시오.
#
# (1) airquality를 AQ에 저장하시오.
AQ <- airquality
# (2) AQ에서 열별로 NA의 개수를 출력하시오.
AQ_count <- apply(AQ,2,function(air)sum(is.na(air)))
AQ_count
# (3) AQ에서 행별로 NA의 개수를 출력하시오.
AQ_count1 <- apply(AQ,1,function(air)sum(is.na(air)))
AQ_count1
# (4) AQ에서 NA를 포함하지 않은 행들만 출력하시오.
AQ[complete.cases(AQ),]
# (5) AQ에서 NA를 NA가 속한 열의 평균값으로 치환하여 AQ2로 저장하고, AQ2의 내용을
# 출력하시오.
colMeans(AQ,na.rm = T)
#
out.val <- boxplot.stats(st$Area)$out <- NA
head(st)
out.val <- boxplot.stats(st$Area)$out
st$Area[st$Area %>% out.val] <- NA
head(st)
# (2) 특이값이 존재하는 경우 이상치를 NA로 대체하여 저장하시오.
out.val <- boxplot.stats(st$Area)$out
st$Area[st$Area %in% out.val] <- NA
head(st)
colMeans(AQ,na.rm = T)
AQ2<- colMeans(AQ,na.rm = T)
AQ@
AQ2
AQ2<- colMeans(AQ,na.rm = T)
AQ2
#Matrix/Data Frame 정렬
head(iris)
order( iris$Sepal.Length )   #정렬시켜주는데 그 정렬시킨애들 순서만을 나타낸다.
iris[order(iris$Sepal.Length),]   #Ascending  #이때 옆에 나오는 숫자는 원래 몇번째에 있던 꽃인지 말해준다.
iris[order(iris$Sepal.Length, decreasing = T),]   #Descending#여기서 처음으로 나오는 꽃은 원래 132번째 꽃이였지만 정렬을 통해서 앞으로 끌고 온다.
iris.new <- iris[order(iris$Sepal.Length),]
head(iris.new)
iris[order(iris$Species,decreasing = T,
iris$Sepal.Length),]    #정렬 기준을 2개 설정.
iris[order(iris$Sepal.Length, decreasing = T),]
#
# 문4)
# R에서 제공하는 state.x77 데이터셋에 대하여 다음 문제를 해결하기 위한
# R 코드를 작성하시오.
#
# (1) state.x77 데이터셋을 Population(인구수)를 기준으로 오름차순 정렬하시오
st <- state.x77
st[order(state$Population)]
st[order(st$Population)]
st[order(st$Population,decreasing = T),]
st[order(st$Population,decreasing = T),]
st1 <- sort(st, decreasing = T)
st1
order( iris$Sepal.Length )   #정렬시켜주는데 그 정렬시킨애들 순서만을 나타낸다.
iris[order(iris$Sepal.Length),]   #Ascending  #이때 옆에 나오는 숫자는 원래 몇번째에 있던 꽃인지 말해준다.
st
st[order(st$Population, decreasing = T),]
state.x77[order(state.x77$Population, decreasing = T), ]
#
# 문4)
# R에서 제공하는 state.x77 데이터셋에 대하여 다음 문제를 해결하기 위한
# R 코드를 작성하시오.
#
# (1) state.x77 데이터셋을 Population(인구수)를 기준으로 오름차순 정렬하시오
class(state.x)
#
# 문4)
# R에서 제공하는 state.x77 데이터셋에 대하여 다음 문제를 해결하기 위한
# R 코드를 작성하시오.
#
# (1) state.x77 데이터셋을 Population(인구수)를 기준으로 오름차순 정렬하시오
class(state.x77)
class(state.x77)
st <- data.frame( state.x77)
st[order(st$Population, decreasing = T),]
state.x77[order(state.x77$Population, decreasing = T), ]
# (2) state.x77 데이터셋을 Income(소득)을 기준으로 내림차순 정렬하시오.
st[order(st$Income),]
st[order(st$Income),]
sstv <-colnames(sort(st))
sstv <- sort(colnames(st$Illiteracy))
sstv
sstv
# (3) Illiteracy(문맹률)가 낮은 상위 10개 주의 이름과 문맹률을 출력하시오.
#
st[order(st$Illiteracy),]
colnames(stt(head(10)))
2) state.x77 데이터셋을 Income(소득)을 기준으로 내림차순 정렬하시오.
st[order(st$Income),]
# (3) Illiteracy(문맹률)가 낮은 상위 10개 주의 이름과 문맹률을 출력하시오.
#
stt<- st[order(st$Illiteracy),]
colnames(stt(head(10)))
st[order(st$Income),]
stt<- st[order(st$Illiteracy),]
colnames(stt(head(10)))
stt[1:10]
stt<- st[order(st$Illiteracy),]
stt[1:10]
stt[,1:10]
stt<- st[order(st$Illiteracy),]
stt[,1:10]
colnames(stt)
rownames
rownames(stt)
stt
rownames(stt[1:10,])
# 문5)
# R에서 제공하는 mtcars 데이터셋에 대하여 다음 문제를 해결하기 위한 R
# 코드를 작성하시오.
#
# (1) mtcars 데이터셋을 gear(기어)의 개수에 따라 그룹을 나누어 mt.gear에 저장하
# 시오.(단, split() 함수를 사용)
class(mtcars)
split(gear,1)
mt.gear<- split(gear,1)
mt.gear<- split(mtcars, mtcars$gear)
mt.gear
mt.gear$4
mt.gear$4
mt.gear$`4`
# (3) mt.gear에서 gear(기어)의 개수가 3인 그룹과 5인 그룹의 데이터를 합쳐서
# mt.gear.35에 저장하고 내용을 출력하시오.
mt.gear3 <- mt.gear$'3'
mt.gear3 <- mt.gear$'3'
mt.gear5 <- mt.gear$'5'
mte.gear.35 <- merge(mt.gear3,mt.gear5)
mt.gear.35 <- merge(mt.gear3,mt.gear5)
mt.gear.35
mt.gear.35 <- merge(mt.gear3,mt.gear5=c('names'))
# (3) mt.gear에서 gear(기어)의 개수가 3인 그룹과 5인 그룹의 데이터를 합쳐서
# mt.gear.35에 저장하고 내용을 출력하시오.
mt.gear3 <- mt.gear$'3'
mt.gear5 <- mt.gear$'5'
mt.gear.35 <- merge(mt.gear3,mt.gear5=c('names'))
mt.gear.35
mt.gear.35 <- merge(mt.gear3,mt.gear5,by=c('names'))
과 5인 그룹의 데이터를 합쳐서
# mt.gear.35에 저장하고 내용을 출력하시오.
mt.gear3 <- mt.gear$'3'
mt.gear5 <- mt.gear$'5'
mt.gear.35 <- merge(mt.gear3,mt.gear5,by=c('names'))
mt.gear.35
mt.gear.35 <- merge(mt.gear3,mt.gear5,all=T)
mt.gear.35
mt.gear$`4`
# (3) mt.gear에서 gear(기어)의 개수가 3인 그룹과 5인 그룹의 데이터를 합쳐서
# mt.gear.35에 저장하고 내용을 출력하시오.
mt.gear3 <- mt.gear$'3'
mt.gear3
mt.gear.35 <- merge(mt.gear3,mt.gear5,all=T)
mt.gear.35
mt.gear5
x <- data.frame(name=c('a','b','c'),
mat= c(90,80,40))
y <- data.frame(sname=c('a','b','d'),
korean=c(75,60,90))
z <- merge(x,y,by.x=c('name'),
by.y = c('sname'))
z
mt.gear5
mt.gear5
mt.gear3
subset(mtcars, wt<=3.0 & wt>=1.5)
merge(authors,books,by.authors=c('surneme'),by.books=c('name'))
authors <- data.frame( surname = c( "Twein", "Venables", "Tierney", "Ripley", "McNeil" ),nationality = c( "US", "Australia", "US", "UK", "Australia" ),retired = c( "yes", rep( "no", 4 ) ) )
books <- data.frame( name = c( "Johns", "Venables", "Tierney", "Ripley", "Ripley", "McNeil" ),title = c( "Exploratory Data Analysis", "Modern Applied Statistics ...", "LISP-STAT","Spatial Statistics", "Stochastic Simulation","Interactive Data Analysis" ),other.author = c( NA, "Ripley", NA, NA, NA, NA ) )
merge(authors,books,by.authors=c('surneme'),by.books=c('name'))
merge(authors,books,all.authors=T)
# (3) surname과 name을 공통 열로 하여 authors와 books를 병합하여 출력하되 books
# 의 행들은 모두 표시되도록 하시오.
rownames(authors)
authors
# (3) surname과 name을 공통 열로 하여 authors와 books를 병합하여 출력하되 books
# 의 행들은 모두 표시되도록 하시오.
merge(authors,books,all.books=T)
books
# (3) surname과 name을 공통 열로 하여 authors와 books를 병합하여 출력하되 books
# 의 행들은 모두 표시되도록 하시오.
merge(books,authors,all.books=T)
# (3) surname과 name을 공통 열로 하여 authors와 books를 병합하여 출력하되 books
# 의 행들은 모두 표시되도록 하시오.
merge(books,authors,
by.authors=c('surname')
all.books=T)
# 의 행들은 모두 표시되도록 하시오.
merge(books,authors,
by.authors=c('surname')
all.books=T)
통 열로 하여 authors와 books를 병합하여 출력하되 books
# 의 행들은 모두 표시되도록 하시오.
merge(books,authors,
by.authors=c('surname'),
all.books=T)
merge(authors,books,
by.books=c('name')
all.authors=T)
merge(authors,books,
by.books=c('name'),
all.authors=T)
merge(books,authors,
by.books=c('surname'),
by.authors=c('other.author'))
