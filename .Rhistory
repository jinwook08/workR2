#select():변수 추출
df %>% select(math)
df %>% select(science)
df %>% select(class,math,science)
df %>% select(-math)
#R에서 가장 많이 사용하는 패키지.
#
#dplyr package
#
install.packages('dplyr')
library(dplyr)
#데이터를 가공할때 가장 많이 사용되는 패키지.
# %>% --> pipe파이프 연산자. c
df <- data.frame(var1=c(1,2,3),
var2=c(2,3,2))
df
#rename: 이름변경
df <- rename(df,v1=var1,v2=var2)
df
##변수 이름을 바꾸는 패키지. dplyr
##파생변수 추가
df$sum <- df$v1 + df$v2
df
#2행1열에 값을 5로 바꾸어 준다.
df[2,1] <- 5
df
df <- data.frame(id=c(1,2,3,4,5,6),
class=c(1,1,1,1,2,2),
math=c(50,60,45,30,25,50),
english=c(98,56,43,21,23,55),
science=c(34,68,87,43,23,77)
)
df
##filter(): 행 추출
df %>% filter(class==1)
df %>% filter(class==2)
df %>% filter(class!=1)
df %>% filter(class!=2)
#입력-> %>% -> 출력
#파이프는 연결기능만 한다.
df %>% filter(science>70)
df %>% filter(math<50)
df %>% filter(class==1&math>=50)
df %>% filter(math>=50|english>=90)
df %>% filter(class %in% c(1,3,5))  #%in% --> 포함여부를 나타내는 명령.
#필터 함수는 행을 추출할때 사용하는 함수이다.
#필터 함수는 조건 식만 주면 된다.
#dplyr 패키지의 가장큰 장점이 파이프 기능.
class1 <-df %>% filter(class==1)
class2 <- df %>% filter(class ==2)
class1
class2
##split 과 비슷하나 별도의 데이터 프레임으로 만들수 있다는게 장점이다.
#select():변수 추출
df %>% select(math)
df %>% select(science)
df %>% select(class,math,science)
df %>% select(-math)
#select():변수 추출
df %>% select(math)
df %>% select(science)
df %>% select(class,math,science)
df %>% select(-math)
class2
source('D:/New-one/workR2/Data preprocessing.R', encoding = 'UTF-8', echo=TRUE)
df %>%
select(id, science) %>%
head
#dplyr 함수 조합.
df %>%
filter(class==1) %>%
select(science)
df %>%
select(id, science) %>%
head
id
df %>%
select(id, science) %>%
sum
df %>%
select(id, science) %>%
max
#arrange ():정렬
df %>% arrange(science)
df %>% arrange(desc(science))
#mutatge():파생변수 추가
df %>%
mutate(total=math+english+science) %>% head
#mutatge():파생변수 추가
df %>%
mutate(total=math+english+science) %>% head
df %>%
mutate(total=math+english+science,
average=(math+english+science)/3)%>% head
df %>%
mutate(grade=ifelse(science>=60,'pass','fail')) %>% head
df %>%
mutate(total=math+english+science,
average=(math+english+science)/3)%>%
mutate(grade=ifelse(average>=90,'pass',
ifelse(average<60,'fail','normal'))) %>%
head
df %>%
mutate(total=math+english+science,
average=(math+english+science)/3)%>%
arrange(desc(average)) %>%
head
df %>%
mutate(total=math+english+science,
average=(math+english+science)/3)%>%
arrange(desc(average)) %>%
head
df %>%
mutate(total=math+english+science,
average=(math+english+science)/3)%>%
mutate(grade=ifelse(average>=90,'pass',
ifelse(average<60,'fail','normal'))) %>%
head
#summarise():집단별 요약
#group_by(): 집단별 나누기.
df %>% summarise(mean_math=mean(math))
df %>% group_by(class) %>%
summarise(mean_math=mean(math),
mean_english=mean(english),
mean_science=mean(science),
n=n())
#summarise():집단별 요약
#group_by(): 집단별 나누기.
df %>% summarise(mean_math=mean(math))
df %>% group_by(class) %>%
summarise(mean_math=mean(math),
mean_english=mean(english),
mean_science=mean(science),
n=n())
#summarise():집단별 요약
#group_by(): 집단별 나누기.
df %>% summarise(mean_math=mean(math))
df %>% group_by(class) %>%
summarise(mean_math=mean(math),
mean_english=mean(english),
mean_science=mean(science),
n=n())
str(ggplot2::mpg)
mpg <- data.frame(ggplot::mpg)
str(mpg)
head(mpg)
view(mpg)
View(mpg)
str(ggplot2::mpg)
mpg <- data.frame(ggplot::mpg)
dim(mpg)
str(mpg)
head(mpg)
View(mpg)
install.packages('ggplot2')
str(ggplot2::mpg)
mpg <- data.frame(ggplot2::mpg)
dim(mpg)
str(mpg)
head(mpg)
View(mpg)
mpg %>% group_by(manufacturer,drv) %>%
summarise(mean_cty=mean(cty)) %>%
head(10)
mpg %>% group_by(manufacturer) %>%
mpg %>% group_by(manufacturer) %>% filter(class=='suv')%>% mutate(tot=(cty+hwy)/2) %>%
summarise(mean_tot=mean(tot)) %>% arrange(desc(mean_tot)) %>% head(5)
mpg %>% group_by(manufacturer,drv) %>%
summarise(mean_cty=mean(cty)) %>%
head(10)
mpg %>% group_by(manufacturer) %>% filter(class=='suv')%>% mutate(tot=(cty+hwy)/2) %>%
summarise(mean_tot=mean(tot)) %>% arrange(desc(mean_tot)) %>% head(5)
#R에서 가장 많이 사용하는 패키지.
#
#dplyr package
#
install.packages('dplyr')
library(dplyr)
#데이터를 가공할때 가장 많이 사용되는 패키지.
# %>% --> pipe파이프 연산자. ctrl + shift + M
df <- data.frame(var1=c(1,2,3),
var2=c(2,3,2))
df
#rename: 이름변경
df <- rename(df,v1=var1,v2=var2)
df
##변수 이름을 바꾸는 패키지. dplyr
##파생변수 추가
df$sum <- df$v1 + df$v2
df
#2행1열에 값을 5로 바꾸어 준다.
df[2,1] <- 5
df
df <- data.frame(id=c(1,2,3,4,5,6),
class=c(1,1,1,1,2,2),
math=c(50,60,45,30,25,50),
english=c(98,56,43,21,23,55),
science=c(34,68,87,43,23,77)
)
df
##filter(): 행 추출
df %>% filter(class==1)
df %>% filter(class==2)
df %>% filter(class!=1)
df %>% filter(class!=2)
#입력-> %>% -> 출력
#파이프는 연결기능만 한다.
df %>% filter(science>70)
df %>% filter(math<50)
df %>% filter(class==1&math>=50)
df %>% filter(math>=50|english>=90)
df %>% filter(class %in% c(1,3,5))  #%in% --> 포함여부를 나타내는 명령.
#필터 함수는 행을 추출할때 사용하는 함수이다.
#필터 함수는 조건 식만 주면 된다.
#dplyr 패키지의 가장큰 장점이 파이프 기능.
class1 <-df %>% filter(class==1)
class2 <- df %>% filter(class ==2)
class1
class2
##split 과 비슷하나 별도의 데이터 프레임으로 만들수 있다는게 장점이다.
#select():변수 추출
df %>% select(math)
df %>% select(science)
df %>% select(class,math,science)
df %>% select(-math)    #math를 빼고 추출해라.
#dplyr 함수 조합.
df %>%
filter(class==1) %>%
select(science)
df %>%
select(id, science) %>%
head
df %>%
select(id, science) %>%
sum
df %>%
select(id, science) %>%
max
#arrange ():정렬 sort함수와 같은 기능.
df %>% arrange(science)#오름차순
df %>% arrange(desc(science)) #내림차순.
#mutatge():파생변수 추가
df %>%
mutate(total=math+english+science) %>% head
df %>%
mutate(total=math+english+science,
average=(math+english+science)/3)%>% head
df %>%
mutate(grade=ifelse(science>=60,'pass','fail')) %>% head
#파생변수 추가할때 이걸 더 많이 쓴다.
df %>%
mutate(total=math+english+science,
average=(math+english+science)/3)%>%
mutate(grade=ifelse(average>=90,'pass',
ifelse(average<60,'fail','normal'))) %>%
head
#평균이 90이상이면 pass 60이하면  fail , 나머지는 normal.
df %>%
mutate(total=math+english+science,
average=(math+english+science)/3)%>%
arrange(desc(average)) %>%
head
#변수의 결과를 가지고 싶으면 반드시 변수에 담아서 저장해라.
#summarise():집단별 요약
#group_by(): 집단별 나누기.
df %>% summarise(mean_math=mean(math))
df %>% group_by(class) %>%              #group_by로 그룹핑 1반 하나 묶고 2반하나 묶어서 이걸로 아래에서 집단별 요약 실행.
summarise(mean_math=mean(math),
mean_english=mean(english),
mean_science=mean(science),
n=n())   #n은 빈도수를 계산해주는 함수이다.
#::--> 스코프 콜론 두개 다음에 나오는 것은 데이터셋 이름.
#패키지만 설치하고 로드 따로 안하고 특정한 패키지가 가지고 있는 데이터 셋을 사용하는 방법을 :: 콜론 두개 뒤에 데이터셋이름이다.
install.packages('ggplot2')
str(ggplot2::mpg)
mpg <- data.frame(ggplot2::mpg)
dim(mpg)
str(mpg)
head(mpg)
View(mpg)
mpg %>% group_by(manufacturer,drv) %>%
summarise(mean_cty=mean(cty)) %>%
head(10)
mpg %>% group_by(manufacturer) %>% filter(class=='suv')%>% mutate(tot=(cty+hwy)/2) %>%
summarise(mean_tot=mean(tot)) %>% arrange(desc(mean_tot)) %>% head(5)
df1 <- data.frame(id=c(1,2,3,4,5),
midterm=c(60,80,70,90,85))
total <- left_join(df1,df2,by='id')
df1 <- data.frame(id=c(1,2,3),
address=c('서울','부산','제주'),
stringsFacrors=F)
df2 <- data.frame(id=c(1,2,4),
gender=c('남','여','남'))
df1 <- data.frame(id=c(1,2,3,4,5),
midterm=c(60,80,70,90,85))
df2 <- data.frame(id=c(1,2,3,4,5),
final=c(60,80,70,90,85))
total <- left_join(df1,df2,by='id')
df1 <- data.frame(id=c(1,2,3),
address=c('서울','부산','제주'),
stringsFacrors=F)
df2 <- data.frame(id=c(1,2,4),
gender=c('남','여','남'))
dㄹ1
df1
df2
total
df_left <- left_join(df1,df2,by='if')
df_left <- left_join(df1,df2,by='id')
df_left
df_inner <- inner_join(df1,df2,by='id')
df_inner
df_full <- full_join(df1,df2,by='id')
df_full
df_inner <- inner_join(df1,df2,by='id')
df_inner
df_full <- full_join(df1,df2,by='id')
df_full
df1 <- data.frame(id=c(1,2,3,4,5),
test=c(60,80,70,90,85))
df2 <- data.frame(id=c(1,2,3,4,5),
test=c(60,80,70,90,85))
df_all <- bind_rows(df1,df2)
df_all
install.packages('pasych')
library(pspych)
library(psych)
install.packages('psych')
library(psych)
install.packages('psych')
library(psych)
install.packages("psych")
summmary(mtcars)
install.packages('psych')
library(psych)
summmary(mtcars)
install.packages("psych")
install.packages('psych')
library(psych)
summmary(mtcars)
summary
summary(mtcars)
describe(mtcars)
install.packages('descr')
require(descr)
table(df$gender)
freq(df$gender, plot = F)
df <- data.frame(id= c(1,2,4),gender=c('남','여','남'))
table(df$gender)
freq(df$gender)
freq(df$gender, plot = F)
freq(df$gender, plot = F)
freq(df$gender, plot = T)
freq(df$gender, plot = F)
freq(df$gender)
# * R Script file 이름은 "영문본인이름_제출일날짜.R" 부여하여 제출
# * R Script file의 처음에 주석으로 본인 이름과 작성일/제출일 기록
#
# 문1)
# 다음과 같이 결측값이 포함된 데이터셋 ds를 생성한 후, 다음 문제를 해결
# 하기 위한 R 코드를 작성하시오.
#
# ds <- state.x77
# ds[2,3] <- NA; ds[3,1] <- NA; ds[2,4] <- NA; ds[4,3] <- NA
#
ds <- state.x77
ds <- state.x77
ds[2,3] <- NA
ds[3,1] <- NA
ds[2,4] <- NA
ds[4,3] <- NA
na_count <- apply(ds,2,function(df)sum(is.na(df)))
na_count
# (2) 결측값이 포함된 행들의 데이터를 출력하시오.
ds[!complete.cases(ds),]
# (3) 결측값이 포함된 행은 몇 개인지 출력하시오.
is.na(ds)
pritn(!complete.cases(ds),)
print(!complete.cases(ds),)
print(names(!complete.cases(ds)),)
names(is.na(ds))
# (3) 결측값이 포함된 행은 몇 개인지 출력하시오.
is.na(ds)
# (3) 결측값이 포함된 행은 몇 개인지 출력하시오.
dd<- is.na(ds)
names(is.na(dd))
# (2) 결측값이 포함된 행들의 데이터를 출력하시오.
ds[!complete.cases(ds),]
# (3) 결측값이 포함된 행은 몇 개인지 출력하시오.
rowSums(is.na(ds))
sum(rowSums(is.na(ds))>0)
# (4) 결측값이 포함된 행들을 제외하고 새로운 데이터셋 ds.new를 만들어보시오.
#
dd <- ds[complete.cases(ds),]
# (4) 결측값이 포함된 행들을 제외하고 새로운 데이터셋 ds.new를 만들어보시오.
#
ds.new <- ds[complete.cases(ds),]
ds.new
st <- data.frame(state.x77)
boxplot(st)
boxplot.stats(st)
boxplot.stats(st)$out
t <- data.frame(state.x77)
boxplot(st)
boxplot.stats(st)$out
boxplot.stats(st$Area)$out
#특이값, 이상치(outlier)
st <- data.frame(state.x77)
summary(st$Income)
boxplot(st$Income)
boxplot.stats(st$Income)$out
#데이터를 알고 이 데이터가 문자열이 맞느냐 숫자형이 맞느냐를 전부 따져보고 그 이후에.
#데이터 분석을할때 가장 먼저 할것 결측치와 이상치부터 찾아본다.
##특이값 처리: NA로 변환 후 결측치 처리방법 이용.
out.val <- boxplot.stats(st$Income)$out
st$Income[st$Income %in% out.val] <- NA    #%in% 포함여부를 나타내는 연산자.
head(st)
newdata <- st[complete.cases(st),]
head(newdata)
########################데이터 정제를 지금까지 해 보았다.
#Data정제를 한다는건
#결측치 처리
#이상치 처리.
state.x
state.x77
out.val <- boxplot.stats(st$Area)$out
summary(st$Area)
st$Area[st$Area %in% out.val] <- NA
head(st)
# (1) st의 각 변수(열)들에 대해 특이값이 존재하는지 상자그림을 그려 확인하시오.
st <- data.frame(state.x77)
boxplot(st)
state.x77
summary(st$Area)
# (2) 특이값이 존재하는 경우 이상치를 NA로 대체하여 저장하시오.
out.val <- boxplot.stats(st$Area)$out
st$Area[st$Area %in% out.val] <- NA
head(st)
new <- st[complete.cases(st),]
head(st)
new <- st[complete.cases(st),]
head(st)
head(new)
# 문3)
# R에서 제공하는 airquality 데이터셋에 대해 다음의 문제를 해결하기 위한
# R 코드를 작성하시오.
#
# (1) airquality를 AQ에 저장하시오.
AQ <- airquality
AQ_count <- apply(AQ,2,function(air)sum(is.na(air)))
AQ_count
# (3) AQ에서 행별로 NA의 개수를 출력하시오.
AQ_count <- apply(AQ,1,function(air)sum(is.na(air)))
AQ_count1 <- apply(AQ,1,function(air)sum(is.na(air)))
AQ_count1
AQ_count1 <- apply(AQ,1,function(air)sum(is.na(air)))
AQ_count1
AQ_count <- apply(AQ,2,function(air)sum(is.na(air)))
AQ_count
# (4) AQ에서 NA를 포함하지 않은 행들만 출력하시오.
AQ[complete.cases(AQ),]
# (2) AQ에서 열별로 NA의 개수를 출력하시오.
AQ_count <- apply(AQ,2,function(air)sum(is.na(air)))
AQ_count
# (5) AQ에서 NA를 NA가 속한 열의 평균값으로 치환하여 AQ2로 저장하고, AQ2의 내용을
# 출력하시오.
apply(AQ,2,mean(AQ[, c(1,2,3,4,5,6)]))
apply(AQ,2,mean(AQ[, c(1,2,3,4,5,6)]))
# (5) AQ에서 NA를 NA가 속한 열의 평균값으로 치환하여 AQ2로 저장하고, AQ2의 내용을
# 출력하시오.
AA <- complete.cases(AQ)
apply(AA,2,mean(AA[, c(1,2,3,4,5,6)]))
apply(AA,2,mean(AA[, c(1,2,3,4,5)]))
AA
# (4) AQ에서 NA를 포함하지 않은 행들만 출력하시오.
AQ[complete.cases(AQ),]
# (5) AQ에서 NA를 NA가 속한 열의 평균값으로 치환하여 AQ2로 저장하고, AQ2의 내용을
# 출력하시오.
AA <- AQ[complete.cases(AQ)]
AA <- AQ[complete.cases(AQ)]
for(i in 1:ncol(AQ)){
this.na <- is.na(AQ[ , i])
cat(colnames(AQ)[i],
"\t", sum(this.na),
'\n')
}
# (5) AQ에서 NA를 NA가 속한 열의 평균값으로 치환하여 AQ2로 저장하고, AQ2의 내용을
# 출력하시오.
AQ[,c(1,2,3,4,5,6)]
AQ
is.na(AQ)
sum(AQ,na.rm=TRUE)
apply(AQ,2,na.rm=TRUE)
apply(AQ,2,na.rm=TRUE)
apply(AQ,2,function(y)na.rm=TRUE)
apply(AQ,2,function(y)mean(AQ,na.rm=TRUE))
apply(AQ,2,mean(AQ,na.rm=TRUE))
st$Area$Incom[st$Area %in% out.val] <- NA
st$Area[st$Area %in% out.val] <- NA %>% st$Population[st$Population %in% out.val] <- NA
out.val <- boxplot.stats(st$Area)$out %>% boxplot.stats(st$Population)$out
# 문2)
# 다음과 같이 state.x77 데이터셋을 st에 저장한 후 다음 문제를 해결하기
# 위한 R 코드를 작성하시오.
#
# st <- data.frame(state.x77)
#
library(dplyr)
# (2) 특이값이 존재하는 경우 이상치를 NA로 대체하여 저장하시오.
out.val <- boxplot.stats(st$Area)$out %>% boxplot.stats(st$Population)$out
st$Area[st$Area %in% out.val] <- NA %>% st$Population[st$Population %in% out.val] <- NA
library(dplyr)
st$Area[st$Area %in% out.val] %>% st$Population[st$Population %in% out.val] <- NA
